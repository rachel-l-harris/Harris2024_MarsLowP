---
title: "Low-Pressure_Mars-Transcriptomics"
author: "Rachel Harris"
date: "12/13/2021"
output: html_document
---

```{r setup, include=FALSE}
#Set working directory 
# setwd("~/Path_to/Harris2024_MarsLowP") # update to source directory

pkgTest <- function(...) {
  # Install dependency libraries if not installed and load them
  dep.list <- c(...)
  new_pkgs <- dep.list[!(dep.list %in% installed.packages()[,"Package"])]
  if(length(new_pkgs)) install.packages(new_pkgs)
  invisible(lapply(dep.list, library, character.only=T))
}
# Load dependencies and setup environment
knitr::opts_chunk$set(echo = TRUE)
library(DESeq2)
library(ggplot2)
library(plotly)
library(dplyr)
library(pheatmap)
library(reshape2)
library(stringr)
library(readxl)
library(WGCNA)
library(devtools)
library(tweeDEseq)



```


```{r, read in transcript counts -- hydrogenotrophic methanogenesis}
H2CO2.protein_list <- as.data.frame(read_excel("~/Documents/Table_S3.xlsx", range = "B22:B55", col_names = TRUE))

H2CO2.GeneID_list <- as.data.frame(read_excel("~/Documents/Table_S3.xlsx", range = "C22:C55", col_names = TRUE))

MarsGas_MAC12mbar_ALLReps <- as.data.frame(read_excel("~/Documents/Table_S3.xlsx",range = "B22:I55", col_names = TRUE))

#Trim to only have gene abbreviations and associated counts
MarsGas_MAC12mbar_ALLReps <- subset(MarsGas_MAC12mbar_ALLReps, select = -c(1,3:4))
MarsGas_MAC12mbar_ALLReps

MarsGas_0C_1.5atm_ALLReps <- as.data.frame(read_excel("~/Documents/Table_S3.xlsx", range = "J22:M55", col_names = TRUE))
MarsGas_0C_1.5atm_ALLReps <- cbind(H2CO2.GeneID_list, MarsGas_0C_1.5atm_ALLReps)

MarsGas_30C_1.5atm_ALLReps <- as.data.frame(read_excel("~/Documents/Table_S3.xlsx", range = "N22:Q55", col_names = TRUE))
MarsGas_30C_1.5atm_ALLReps <- cbind(H2CO2.GeneID_list, MarsGas_30C_1.5atm_ALLReps)

H2CO2Gas_MAC12mbar_ALLReps <- as.data.frame(read_excel("~/Documents/Table_S3.xlsx", range = "S22:X55", col_names = TRUE))
H2CO2Gas_MAC12mbar_ALLReps <- cbind(H2CO2.GeneID_list, H2CO2Gas_MAC12mbar_ALLReps)

H2CO2Gas_0C_1.5atm_ALLReps <- as.data.frame(read_excel("~/Documents/Table_S3.xlsx", range = "Y22:AD55", col_names = TRUE))
H2CO2Gas_0C_1.5atm_ALLReps <- cbind(H2CO2.GeneID_list, H2CO2Gas_0C_1.5atm_ALLReps)

H2CO2Gas_30C_1.5atm_ALLReps <- as.data.frame(read_excel("~/Documents/Table_S3.xlsx", range = "AE22:AJ55", col_names = TRUE))
H2CO2Gas_30C_1.5atm_ALLReps <- cbind(H2CO2.GeneID_list, H2CO2Gas_30C_1.5atm_ALLReps)
```

```{r, make count matrix K}
K <- as.matrix(cbind(MarsGas_MAC12mbar_ALLReps[,2:5], MarsGas_30C_1.5atm_ALLReps[,2:5],
                     MarsGas_0C_1.5atm_ALLReps[,2:5],
           H2CO2Gas_MAC12mbar_ALLReps[,2:7], H2CO2Gas_30C_1.5atm_ALLReps[,2:7],
           H2CO2Gas_0C_1.5atm_ALLReps[,2:7]))
rownames(K) <- MarsGas_MAC12mbar_ALLReps$Abbreviation

#replace NAs with 0 
K[is.na(K)] <- 0
#turn entries in scientific notation into integers
K <- apply(K, 1:2, function(x) as.integer(x))

colDataK <- as.data.frame(matrix(nrow=ncol(K), ncol = 4))
rownames(colDataK) <- colnames(K); colnames(colDataK) <- c("Gas", "Pressure", "Temperature",
                                                           "Replicate")

colDataK$Gas <- as.factor(ifelse(grepl("MarsGas", rownames(colDataK), ignore.case = T), "Mars_H2", "H2CO2"))
colDataK$Pressure <- as.factor(ifelse(grepl("12mbar", rownames(colDataK), ignore.case = T), "12", "1500"))
colDataK$Temperature <- as.factor(ifelse(grepl("30C", rownames(colDataK), ignore.case = T), "30", "0"))
colDataK$Replicate <- as.factor(ifelse(grepl("Rep1", rownames(colDataK), ignore.case = T), "1",
                                       ifelse(grepl("Rep2", rownames(colDataK), ignore.case = T), "2",
                                              ifelse(grepl("Rep3", rownames(colDataK),
                                                           ignore.case = T), "3",
                                                     ifelse(grepl("Rep4", rownames(colDataK),
                                                                  ignore.case = T), "4",
                                                     ifelse(grepl("Rep5", rownames(colDataK),
                                                                  ignore.case = T), "5", "6"))))))

all(rownames(colDataK) == colnames(K)) #sanity check
```

```{r, single variable differential expression}

#assess all variables if possible#
#relevel to reference control conditions
colDataK$Pressure <- relevel(colDataK$Pressure, "1500")
colDataK$Gas <- relevel(colDataK$Gas, "H2CO2")
colDataK$Temperature <- relevel(colDataK$Temperature, "30")
dds.LPMM <- DESeqDataSetFromMatrix(countData = K,
                                  colData = colDataK,
                                  design = ~ Pressure + Gas + Temperature + Replicate) 
##################
#model zero component using *zinbwave*
library(zinbwave)
library(BiocParallel)
library(splatter)

### Simulate single-cell count data with *splatter*
suppressPackageStartupMessages(library(splatter))
params <- newSplatParams()
#params
#slotNames(params)
# note: these DE params are natural log scale
params <- setParam(params, "de.facLoc", 1) 
params <- setParam(params, "de.facScale", .25)
# add a lot more dropout - see if ZI weighting works
params <- setParam(params, "dropout.type", "experiment")
params <- setParam(params, "dropout.mid", 3)

set.seed(1)
sim <- splatSimulate(params, group.prob=c(.5,.5), method="groups")
# hist(rowSums(counts(sim) >= 1))

#dropout
plot(log10(rowMeans(assays(sim)[["TrueCounts"]])), rowMeans(assays(sim)[["Dropout"]]))

# note: each group gets it's own DE genes -- meaning some will be "doubly DE"
#z <- rowData(sim)$DEFacGroup1
#hist(log(z[z > 1]), breaks=30, col="grey", freq=FALSE, ylim=c(0,5))
rowData(sim)$log2FC <- with(rowData(sim), log2(DEFacGroup2/DEFacGroup1))

#trueDisp
rowData(sim)$trueDisp <- rowMeans(assays(sim)[["BCV"]])^2
gridlines <- c(1e-2,1e-1,1); cols <- c("blue","red","darkgreen")
with(rowData(sim)[rowData(sim)$GeneMean> 1,],
     plot(GeneMean, trueDisp, log="xy", xlim=c(1,300), ylim=c(.01,5)))
abline(h=gridlines, col=cols)
text(300, gridlines, labels=gridlines, col=cols, pos=3)

# low count filter - at least 10 with count of 5 or more
keep <- rowSums(counts(sim) >= 5) >= 10
table(keep)
zinb <- sim[keep,]
zinb$condition <- factor(zinb$Group)
# we need to reorganize the assays in the SumExp from splatter
nms <- c("counts", setdiff(assayNames(zinb), "counts"))
assays(zinb) <- assays(zinb)[nms]
assay(zinb) <- as.matrix(assay(zinb))
# epsilon setting as recommended by the ZINB-WaVE integration paper
system.time({
  zinb <- zinbwave(zinb, K=0, observationalWeights=TRUE,
                   BPPARAM=SerialParam(), epsilon=1e12)
})



##############################
# calculate geometric means prior to estimate size factors
gm_mean = function(x, na.rm=TRUE){
  exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))
}

#remove replicates where transcript counts are 0 for every gene
dds.LPMM_v2 <- dds.LPMM[, colSums(counts(dds.LPMM) !=0) > 0]
dds.LPMM_v2 = estimateSizeFactors(dds.LPMM_v2, type = "poscounts")
res.LPMM = DESeq(dds.LPMM_v2, fitType="local")
#> using pre-existing size factors
#> estimating dispersions
#> gene-wise dispersion estimates
#> mean-dispersion relationship
#> final dispersion estimates
#> fitting model and testing

resultsNames(res.LPMM)
#Relevant ones: •Pressure_12_vs_1500 •Gas_Mars_H2_vs_H2CO2 •Temperature_0_vs_30

library(apeglm)
Pressure_12_vs_1500 <- lfcShrink(res.LPMM, coef = "Pressure_12_vs_1500", type = "apeglm")
Gas_Mars_H2_vs_H2CO2 <- lfcShrink(res.LPMM, coef = "Gas_Mars_H2_vs_H2CO2", type = "apeglm")
Temperature_0_vs_30 <- lfcShrink(res.LPMM, coef = "Temperature_0_vs_30", type = "apeglm")

write.csv(Pressure_12_vs_1500, file = "~/Documents/Pressure_12_vs_1500_zeroInflation.csv")
write.csv(Gas_Mars_H2_vs_H2CO2, file = "~/Documents/Gas_Mars_H2_vs_H2CO2_zeroInflation.csv")
write.csv(Temperature_0_vs_30, file = "~/Documents/Temperature_0_vs_30_zeroInflation.csv")

sig_Pressure_12_vs_1500 <- as.data.frame(subset(Pressure_12_vs_1500, padj <= 0.05))
sig_Gas_Mars_H2_vs_H2CO2 <- as.data.frame(subset(Gas_Mars_H2_vs_H2CO2, padj <= 0.05))
sig_Temperature_0_vs_30 <- as.data.frame(subset(Temperature_0_vs_30, padj <= 0.05))

write.csv(sig_Pressure_12_vs_1500, file = "~/Documents/sig_Pressure_12_vs_1500.csv")
write.csv(sig_Gas_Mars_H2_vs_H2CO2, file = "~/Documents/sig_Gas_Mars_H2_vs_H2CO2.csv")
write.csv(sig_Temperature_0_vs_30, file = "~/Documents/sig_Gas_Temperature_0_vs_30.csv")
```

```{r, heatmap of normalized counts}
library(pheatmap)

normFactors <- matrix(runif(nrow(dds.LPMM_v2)*ncol(dds.LPMM_v2),0.5,1.5),
                      ncol=ncol(dds.LPMM_v2),nrow=nrow(dds.LPMM_v2),
                      dimnames=list(1:nrow(dds.LPMM_v2),1:ncol(dds.LPMM_v2)))

# the normalization factors matrix should not have 0's in it
# it should have geometric mean near 1 for each row
normFactors <- normFactors / exp(rowMeans(log(normFactors)))
normalizationFactors(dds.LPMM_v2) <- normFactors

select <- order(rowMeans(counts(dds.LPMM_v2,normalized=TRUE)),
                decreasing=FALSE)[1:length(dds.LPMM_v2)]

select <- order(rowMeans(counts(dds.LPMM_v2,normalized=TRUE)),
                decreasing=TRUE)

df <- as.data.frame(colData(dds.LPMM_v2)[,c("Gas","Pressure", "Temperature")])

#calculate effects of transformations on variance
ntd <- normTransform(dds.LPMM_v2) #this gives log2(n+1)
library(vsn)
#The figure below plots the standard deviation of the transformed data, across samples, against the mean, using the shifted logarithm transformation, the regularized log transformation and the variance stabilizing transformation. The shifted logarithm has elevated standard deviation in the lower count range, and the regularized log to a lesser extent, while for the variance stabilized data the standard deviation is roughly constant along the whole dynamic range.

#Note that the vertical axis in such plots is the square root of the variance over all samples, so including the variance due to the experimental conditions. While a flat curve of the square root of variance over the mean may seem like the goal of such transformations, this may be unreasonable in the case of datasets with many true differences due to the experimental conditions.
meanSdPlot(assay(ntd))
```

```{r, clustering using k-means}
#01/04/2023
#https:/2-bitbio.com/2017/10/clustering-rnaseq-data-using-k-means.html
#scale data in order to identify clusters of genes that share similar expression profiles rather than similar expression levels
scaledata <- t(scale(t(assay(ntd))))

#cluster samples to identify outliers
hc <- hclust(as.dist(1-cor(scaledata, method = "spearman")), method = "complete") #cluster columns by Spearman correlation
TreeC <- as.dendrogram(hc, method = "average")
library(ggdendro)
# plot(TreeC,
#      main = "Sample Clustering",
#      ylab = "Height")
# 
# ggdendrogram(TreeC, rotate = TRUE, size = 2)+
#   ylab("Height")+
#   xlab("Sample Clustering")

#K-means clustering
# Sum of Squared Error (SSE): the sum of the squared distance between each member of a cluster and its cluster centroid
wss <- (nrow(scaledata)-1)*sum(apply(scaledata,2,var))
for (i in 2:30) wss[i] <- sum(kmeans(scaledata,
                                     centers = i)$withinss)
plot(1:30, wss, type = "b", xlab = "Number of Clusters", ylab = "Within groups sum of squares")

#average silhouette width
#the silhouette value describes how similar a gene is to its own cluster (cohesion) compared to other clusters (separation). 
# A high value indicates the gene is well placed.
# If the average of all silhouettes is high then the number of clusters is good

library(cluster)
sil <- rep(0,30)
#repeat k-means for 1:30 and extract silhouette:
for (i in 2:30){
  k1to30 <- kmeans(scaledata, centers = i, nstart = 25, iter.max = 30)
  ss <- silhouette(k1to30$cluster, dist(scaledata))
  sil[i] <- mean(ss[,3])
}

#plot the average silhouette width
plot(1:30, sil, type = "b", pch = 19, xlab = "Number of clusters k", ylab = "Average silhouette width")+
abline(v = which.max(sil), lty = 2)
cat("average silhouette width optimal number of clusters", which.max(sil), "\n")
# average silhouette width optimal number of clusters 2 

#Calinsky criterion:
# This is based on the intra and inter cluster sum of squares
# You are looking to maximize the index to find well separated clusters. 
# To do this, repeatedly cluster data then look how genes partition
# themselves with increasing K

library(vegan)
fit <- cascadeKM(scaledata, 1, 30, iter = 100)
plot(fit, sortg = TRUE, grpmts.plot = TRUE)

calinsky.best <- as.numeric(which.max(fit$results[2,]))
calinsky.best #Calinski criterion optimal number of clusters: 2

#gap statistic
#This compares the log within-cluster sum of squares with its expectation
#under the null reference distribution.
# Then it chooses the cluster where the gap between the low(wss) and the maximum of the null ref is largest
set.seed(13)
gap <- clusGap(scaledata, kmeans, 20, B = 100, verbose = interactive())
plot(gap, main = "Gap statistic")+
  abline(v=which.max(gap$Tab[,3]), lty = 2)
#you can see that 18 clusters is the max but 6ish is just as good

#Affinity propogation:
#Uses representatives from the data called 'exemplars' to build clusters in a way that's similar to partitioning
#around medoids. It doesn't require designating a cluster number.
library(apcluster)
d.apclus <- apcluster(negDistMat(r = 2), scaledata)
d.apclus7 <- d.apclus*7
length(d.apclus@clusters) #affinity propogation optimal number of clusters: 7
heatmap(d.apclus,cexRow=0, cexCol=0)

```

```{r Actually clustering the data}
#Using K=7 as determined by affinity propogation
kClust <- kmeans(scaledata, centers = 7, nstart = 1000, iter.max = 20)
kClusters <- kClust$cluster

#calculate cluster 'cores' aka centroids
#function to find centroid in cluster i
clust.centroid = function(i, dat, clusters) {
  ind = (clusters == i)
  colMeans(dat[ind,, drop = FALSE])
}
kClustcentroids <- sapply(levels(factor(kClusters)), clust.centroid, scaledata, kClusters)

#Plot centroids to see how they behave
library(reshape)
#get in long form for plotting
Kmolten <- melt(kClustcentroids)
colnames(Kmolten) <- c("sample", "cluster", "value")

#plot
p1 <- ggplot(Kmolten, aes(x=sample,y=value, group=cluster, colour=as.factor(cluster))) + 
  geom_point() + 
  geom_line() +
  xlab("Sample") +
  ylab("Expression") +
  labs(title= "Cluster Expression by Sample",color = "Cluster")+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 45, hjust = 0.95, color = "black"))
p1

#correlate medoids to see how similar they are
#if the centroids are too similar then they will have high correlation
# If your K number produces clusters with high correlation (say above 0.85), then consider reducing the number of clusters
cor(kClustcentroids) # <- clusters are very similar with correlation between 0.78 (b/w clusters 7 and 7) and nearly 1


```


```{r Using a cluster score to identify core genes}
#calculating membership score for clusters can help identify core genes whose expression closely match the core
#These gene might play a role in determining the expression of the cluster as a whole
#These scores can be used to a posteriori filter genes if you want to drop genes
#that don't fit well into any cluster

#to calculate scores for a single cluster (in this case 2), extract core data for cluster 2
#then subset the scaled data by cluster = 2. then, calculate the score by correlating each gene with the
#cluster core. Then plot the results for each gene with the score overlayed

#Subset the cores molten dataframe so we can plot the core
core2 <- Kmolten[Kmolten$cluster=="2",]

#get cluster 2
K2 <- (scaledata[kClusters==2,])
#calculate the correlation with the core
corscore <- function(x){cor(x,core2$value)}
score <- apply(K2, 1, corscore)
#get the data frame into long format for plotting
K2molten <- melt(K2)
colnames(K2molten) <- c('gene','sample','value')
#add the score
K2molten <- merge(K2molten,score, by.x='gene',by.y='row.names', all.x=T)
colnames(K2molten) <- c('gene','sample','value','score')
#order the dataframe by score
#to do this first create an ordering factor
K2molten$order_factor <- 1:length(K2molten$gene)
#order the dataframe by score
K2molten <- K2molten[order(K2molten$score),]
#set the order by setting the factors
K2molten$order_factor <- factor(K2molten$order_factor , levels = K2molten$order_factor)

# Everything on the same plot
p2 <- ggplot(K2molten, aes(x=sample,y=value)) + 
  geom_line(aes(colour=score, group=gene)) +
  scale_colour_gradientn(colours=c('blue1','red2')) +
  #this adds the core 
  geom_line(data=core2, aes(sample,value, group=cluster), color="black",inherit.aes=FALSE) +
  xlab("Sample") +
  ylab("Expression") +
  labs(title= "Cluster 2 Expression by Sample",color = "Score")+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 45, hjust = 0.95, color = "black"))
p2
```

```{r zscore heatmap}
Zscore.pheatmap <- pheatmap(assay(rld)[select,], cluster_rows=FALSE, show_rownames=TRUE,
         show_colnames=TRUE, cluster_cols=FALSE, annotation_col=df)

# Row Z-Score is a scaling method for visualization in heat maps that helps enhance clusters of genes with similar trends in expression between samples.
# 
# Z-Score is calculated by:
# 
# (Gene expression value in sample of interest) - (Mean expression across all samples) / Standard Deviation

Zscore.pheatmap
```


```{r, estimation of dispersion}
#estimation of dispersion trend
rld <- rlog(dds.LPMM_v2, blind=FALSE, fitType = "local") #apply a regularized log transformation to minimize differences
                                  #between samples for rows with small counts and normalizes with respect to library size
                                  #rlog produces similar variance stabilizing effect as varianceStabilizingTransformation but is more
                                  #robust  when size factors vary widely
                                  #if many genes have large differences in counts due to experimental design, it is important to set
                                  #blind=FALSE for downstream analyses
meanSdPlot(assay(rld))

sampleDists <- dist(t(assay(rld)))
sampleScale <- t(scale(t(assay(rld))))
  
library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
sampleScaleMatrix <- as.matrix(sampleScale)
rownames(sampleScaleMatrix) <- rownames(rld)
rownames(sampleDistMatrix) <- colnames(rld)
colnames(sampleDistMatrix) <- NULL
colnames(sampleScaleMatrix) <- NULL
colors <- colorRampPalette(rev(brewer.pal(9, "Blues")) )(255)
sample.pheatmap <- pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors,
         show_rownames=TRUE)


```


```{r PCAs}
pcaData_GP <- plotPCA(rld, intgroup=c("Gas", "Pressure"), returnData=TRUE)
percentVar_GP <- round(100 * attr(pcaData_GP, "percentVar"))
plot.pcaData_GP <- ggplot(pcaData_GP, aes(PC1, PC2, color=Gas, shape=Pressure)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar_GP[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar_GP[2],"% variance")) + 
  coord_fixed()+
  theme_classic()

plot.pcaData_GP

pcaData_GPT <- plotPCA(rld, intgroup=c("Gas", "Pressure", "Temperature"), returnData = TRUE)
pcaData_GPT


percentVar_GPT <- round(100 * attr(pcaData_GPT, "percentVar"))
plot.pcaData_GPT <- ggplot(pcaData_GPT, aes(PC1, PC2, color=Gas, shape=Pressure, size = Temperature)) +
  geom_point() +
  xlab(paste0("PC1: ",percentVar_GPT[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar_GPT[2],"% variance")) + 
  coord_fixed()+
  theme_classic()

plot.pcaData_GPT

pcaData_GT <- plotPCA(rld, intgroup=c("Gas", "Temperature"), returnData=TRUE)
plot.pcaData_GT <- ggplot(pcaData_GT, aes(PC1, PC2, color=Gas, shape=Temperature)) +
  geom_point(size = 3) +
  xlab(paste0("PC1: ",percentVar_GPT[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar_GPT[2],"% variance")) + 
  coord_fixed()+
  theme_classic()

plot.pcaData_GT

```


```{r, NMDS}
library(vegan)

#sample-level k clustering above by condition against regularized-log transformations
scaledata.t <- scale(t(assay(rld))) #centers and scales data

#get grouping information
grouping.info <- data.frame(row.names = rownames(scaledata.t), t(as.data.frame(strsplit(rownames(scaledata.t), "_"))))
head(grouping.info)

#remove empty rows from K.t
#remove replicates where transcript counts are 0 for every gene
scale.data.t_clean <- scaledata.t[rowSums(scaledata.t) !=0,]
#update grouping.info to only keep samples whose names match scale.data.t_clean
grouping.info <- grouping.info[rownames(scale.data.t_clean),]
#get MDS stats
set.seed(18272)
sol <- metaMDS(scale.data.t_clean, distance = "bray", k = 2, trymax = 5000) 
sol #The best solution was repeated one time in 1172 tries; the best solution was from try 106 (random start)

data.scores <- as.data.frame(scores(sol))
#add columns to data frame 
data.scores$Sample <- rownames(grouping.info)
data.scores$Gas <- as.factor(grouping.info$X1)
data.scores$Temperature <- as.factor(grouping.info$X2)
data.scores$Pressure <- as.factor(grouping.info$X3)
data.scores$Replicate <- as.factor(grouping.info$X4)

head(data.scores)

#Get spread of points based on gas
plot.new()
ord<-ordiellipse(sol, as.factor(grouping.info$X1) ,display = "sites", kind ="sd", conf = 0.95, label = T)
dev.off()

#Reference: http:/stackoverflow.com/questions/13794419/plotting-ordiellipse-function-from-vegan-package-onto-nmds-plot-created-in-ggplo
#Data frame df_ell contains values to show ellipses. It is calculated with function veganCovEllipse which is hidden in vegan package. This function is applied to each level of NMDS (group) and it uses also function cov.wt to calculate covariance matrix.
veganCovEllipse<-function (cov, center = c(0, 0), scale = 1, npoints = 100) 
{
  theta <- (0:npoints) * 2 * pi/npoints
  Circle <- cbind(cos(theta), sin(theta))
  t(center + scale * t(Circle %*% chol(cov)))
}
 


#Generate ellipse points
df_ell <- data.frame()
for(g in levels(data.scores$Gas)){
  if(g!="" && (g %in% names(ord))){
 
    df_ell <- rbind(df_ell, cbind(as.data.frame(with(data.scores[data.scores$Gas==g,],
                                                     veganCovEllipse(ord[[g]]$cov,ord[[g]]$center,ord[[g]]$scale)))
                                  ,Gas=g))
  }
}

data.scores.mean_Gas <- aggregate(data.scores[,1:2], list(group=data.scores$Gas),mean)
data.scores.mean_Temperature <- aggregate(data.scores[,1:2], list(group=data.scores$Temperature),mean)
data.scores.mean_Pressure <- aggregate(data.scores[,1:2], list(group=data.scores$Pressure),mean)

shape_values <- c(21, 24)

plot.NMDS_gas <- ggplot(data.scores, aes(x = NMDS1, y = NMDS2)) + 
    geom_point(aes(shape = Pressure, fill = Gas, size = Temperature), color = "black", position=position_jitter(h=1, w=1), alpha = 0.7)+ 
    theme(axis.text.y = element_text(colour = "black", size = 12, face = "bold"), 
    axis.text.x = element_text(colour = "black", face = "bold", size = 12), 
    legend.text = element_text(size = 12, face ="bold", colour ="black"), 
    legend.position = "right", axis.title.y = element_text(face = "bold", size = 14), 
    axis.title.x = element_text(face = "bold", size = 14, colour = "black"), 
    legend.title = element_text(size = 14, colour = "black", face = "bold"), 
    panel.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1.2),
    legend.key=element_blank()) +
    scale_fill_manual(values = c("#009E73", "#E69F00"))+
    scale_shape_manual(values = shape_values)+
    scale_size_manual(values = c(2,4.5))+
    labs(x = "NMDS1", fill = "Gas", y = "NMDS2", shape = "Pressure", size = "Temperature")+
    annotate("text",x=data.scores.mean_Gas$NMDS1, y=data.scores.mean_Gas$NMDS2, label=data.scores.mean_Gas$group, size=3.5, vjust = -1.5)+
    geom_path(data=df_ell, aes(x=NMDS1, y=NMDS2, color = Gas), size=0.5, linetype=2)+
    coord_equal()+
    scale_color_manual(values = c("#009E73", "#E69F00"))

plot.NMDS_gas

#Get spread of points based on Temperature
plot.new()
ord<-ordiellipse(sol, as.factor(grouping.info$X2) ,display = "sites", kind ="sd", conf = 0.95, label = T)
dev.off()

df_ell_Temperature <- data.frame()
for(g in levels(data.scores$Temperature)){
  if(g!="" && (g %in% names(ord))){
 
    df_ell_Temperature <- rbind(df_ell_Temperature, cbind(as.data.frame(with(data.scores[data.scores$Temperature==g,],
                                                     veganCovEllipse(ord[[g]]$cov,ord[[g]]$center,ord[[g]]$scale)))
                                  ,Temperature=g))
  }
}

plot.NMDS_Temperature <- ggplot(data.scores, aes(x = NMDS1, y = NMDS2)) + 
    geom_point(aes(shape = Pressure, fill = Gas, size = Temperature), color = "black", position=position_jitter(h=1, w=1))+ 
    theme(axis.text.y = element_text(colour = "black", size = 12, face = "bold"), 
    axis.text.x = element_text(colour = "black", face = "bold", size = 12), 
    legend.text = element_text(size = 12, face ="bold", colour ="black"), 
    legend.position = "right", axis.title.y = element_text(face = "bold", size = 14), 
    axis.title.x = element_text(face = "bold", size = 14, colour = "black"), 
    legend.title = element_text(size = 14, colour = "black", face = "bold"), 
    panel.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1.2),
    legend.key=element_blank()) +
    scale_fill_manual(values = c("#009E73", "#E69F00"))+
    scale_shape_manual(values = shape_values)+
    scale_size_manual(values = c(2,4.5))+
    labs(x = "NMDS1", fill = "Gas", y = "NMDS2", shape = "Pressure", size = "Temperature")+
    geom_path(data=df_ell_Temperature, aes(x=NMDS1, y=NMDS2, color = Temperature), size=0.5, linetype=2)+
    coord_equal()+
    scale_color_manual(values = c("#009E73", "#E69F00"))

plot.NMDS_Temperature

#Get spread of points based on Pressure
plot.new()
ord<-ordiellipse(sol, as.factor(grouping.info$X3) ,display = "sites", kind ="sd", conf = 0.95, label = T)
dev.off()

df_ell_pressure <- data.frame()
for(g in levels(data.scores$Pressure)){
  if(g!="" && (g %in% names(ord))){
 
    df_ell_pressure <- rbind(df_ell_pressure, cbind(as.data.frame(with(data.scores[data.scores$Pressure==g,],
                                                     veganCovEllipse(ord[[g]]$cov,ord[[g]]$center,ord[[g]]$scale)))
                                  ,Pressure=g))
  }
}

plot.NMDS_Pressure <- ggplot(data.scores, aes(x = NMDS1, y = NMDS2)) + 
    geom_point(aes(shape = Pressure, fill = Gas, size = Temperature), color = "black", position=position_jitter(h=1, w=1))+ 
    theme(axis.text.y = element_text(colour = "black", size = 12, face = "bold"), 
    axis.text.x = element_text(colour = "black", face = "bold", size = 12), 
    legend.text = element_text(size = 12, face ="bold", colour ="black"), 
    legend.position = "right", axis.title.y = element_text(face = "bold", size = 14), 
    axis.title.x = element_text(face = "bold", size = 14, colour = "black"), 
    legend.title = element_text(size = 14, colour = "black", face = "bold"), 
    panel.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1.2),
    legend.key=element_blank()) +
    scale_fill_manual(values = c("#009E73", "#E69F00"))+
    scale_shape_manual(values = shape_values)+
    scale_size_manual(values = c(2,4.5))+
    #labs(x = "NMDS1", fill = "Gas", y = "NMDS2", shape = "Pressure", size = "Temperature")+
    #annotate("text",x=data.scores.mean_Pressure$NMDS1, y=data.scores.mean_Pressure$NMDS2, label=data.scores.mean_Pressure$group, size=3.5, vjust = -1.5)+
    geom_path(data=df_ell_pressure, aes(x=NMDS1, y=NMDS2, color = Pressure), size=0.5, linetype=2)+
    coord_equal()+
    scale_color_manual(values = c("#009E73", "#E69F00"))

plot.NMDS_Pressure
  
```

```{r, repeat sample-level k clustering}

########01/04/2023 
#repeat sample-level k clustering above by condition against regularized log transformations
scaledata <- t(scale(t(assay(rld)))) #centers and scales data

#cluster samples to identify outliers
hr <- hclust(as.dist(1-cor(scaledata, method = "pearson")), method = "complete") #cluster columns by Pearson correlation
hc <- hclust(as.dist(1-cor(scaledata, method = "spearman")), method = "complete") #cluster columns by Spearman correlation

#Affinity propogation:
#Uses representatives from the data called 'exemplars' to build clusters in a way that's similar to partitioning
#around medoids. It doesn't require designating a cluster number.
library(apcluster)
d.apclus <- apcluster(negDistMat(r = 2), scaledata)
length(d.apclus@clusters) #affinity propogation optimal number of clusters: 6
heatmap(d.apclus,cexRow=0, cexCol=0)


kClust <- kmeans(scaledata, centers = 6, nstart = 1000, iter.max = 20)
kClusters <- kClust$cluster

#calculate cluster 'cores' aka centroids
#function to find centroid in cluster i
clust.centroid = function(i, dat, clusters) {
  ind = (clusters == i)
  colMeans(dat[ind,, drop = FALSE])
}
kClustcentroids <- sapply(levels(factor(kClusters)), clust.centroid, scaledata, kClusters)

#Plot centroids to see how they behave
#get in long form for plotting
Kmolten <- melt(kClustcentroids)
colnames(Kmolten) <- c("sample", "cluster", "value")

#plot
p1 <- ggplot(Kmolten, aes(x=sample,y=value, group=cluster, colour=as.factor(cluster))) + 
  geom_point() + 
  geom_line() +
  xlab("Sample") +
  ylab("Expression") +
  labs(title= "Cluster Expression by Sample",color = "Cluster")+
  theme_classic()+
  theme(axis.text.x = element_text(angle = 45, hjust = 0.95, color = "black"))
p1

#correlate medoids to see how similar they are
#if the centroids are too similar then they will have high correlation
# If your K number produces clusters with high correlation (say above 0.85), then consider reducing the number of clusters
cor(kClustcentroids) # <- clusters are very similar with correlation between 0.8478803 (b/w clusters 3 and 7) and nearly 1

```

```{r, ggplot gas type differential expression}
Res.Gas_Mars_H2_vs_H2CO2 <- as.data.frame(read_excel("~/Documents/Gas_Mars_H2_vs_H2CO2_zeroInflation.xlsx", sheet = 1, range = "A1:J35", col_names = TRUE))

Res.Gas_Mars_H2_vs_H2CO2$Pathway_Position <- c(1:34)

ggplot_Gas <- ggplot(Res.Gas_Mars_H2_vs_H2CO2, aes(x = Pathway_Position, y = log2FoldChange, color = `Significant?`, label = GeneID))+
  geom_point()+
  geom_label(hjust = 0.5, vjust = 0, aes(size = baseMean))+
  scale_size_area()+
  coord_flip()+
  theme_minimal()+
  scale_x_reverse()+
  geom_errorbar(aes(ymin = log2FoldChange - lfcSE, ymax = log2FoldChange + lfcSE), width = 1)+
  geom_hline(aes(yintercept = 0), color = "black")+
  ylab("Log Fold Change ± SE")+
  scale_color_manual(values = c("black", "red"))+
  theme(axis.title.x = element_text(size = 20),
        axis.text.x = element_text(size = 19),
        axis.title.y = element_text(size = 20),
        axis.text.y = element_text(size = 19),
        legend.title = element_text(size = 20),
        legend.text = element_text(size = 19),
        legend.text.align = 0)

ggplot_Gas

ggsave("plot.Gas_L2FC.pdf", plot = ggplot_Gas, path = "~/Documents/", width = 8.5, height = 8.5, dpi = 300, device = cairo_pdf)

```


```{r, ggplot Pressure differential expression}
Res.Pressure_Mars_12_vs_1500 <- as.data.frame(read_excel("~/Documents/Pressure_12_vs_1500_zeroInflation.xlsx", sheet = 1, range = "A1:J35", col_names = TRUE))
Res.Pressure_Mars_12_vs_1500$Pathway_Position <- c(1:34)

ggplot_Pressure <- ggplot(Res.Pressure_12_vs_1500, aes(x = Pathway_Position, y = log2FoldChange, color = `Significant?`, label = GeneID))+
  geom_point()+
  geom_label(hjust = 0.5, vjust = 0.5, aes(size = baseMean))+
  scale_size_area()+
  coord_flip()+
  theme_minimal()+
  scale_x_reverse()+
  geom_errorbar(aes(ymin = log2FoldChange - lfcSE, ymax = log2FoldChange + lfcSE), width = 1)+
  geom_hline(aes(yintercept = 0), color = "black")+
  ylab("Log Fold Change ± SE")+
  scale_color_manual(values = c("black", "red"))+
  theme(axis.title.x = element_text(size = 20),
        axis.text.x = element_text(size = 19),
        axis.title.y = element_text(size = 20),
        axis.text.y = element_text(size = 19),
        legend.title = element_text(size = 20),
        legend.text = element_text(size = 19),
        legend.text.align = 0)

ggplot_Pressure

ggsave("plot.Pressure_L2FC.pdf", plot = ggplot_Pressure, path = "~/Documents/", width = 8.5, height = 8.5, dpi = 300, device = cairo_pdf)

```

```{r, ggplot temperature differential expression}

Res.Temp_0_vs_30 <- as.data.frame(read_excel("~/Documents/Temperature_0_vs_30_zeroInflation.xlsx", sheet = 1, range = "A1:J35", col_names = TRUE))
Res.Temp_0_vs_30$Pathway_Position <- c(1:34)

ggplot_Temp <-  ggplot(Res.Temp_0_vs_30, aes(x = Pathway_Position, y = log2FoldChange, color = `Significant?`, label = GeneID))+
  geom_point()+
  geom_label(hjust = 0.5, vjust = 0.5, aes(size = baseMean))+
  scale_size_area()+
  coord_flip()+
  theme_minimal()+
  scale_x_reverse()+
  #geom_errorbar(aes(ymin = log2FoldChange - lfcSE, ymax = log2FoldChange + lfcSE), width = 1)+
  geom_hline(aes(yintercept = 0), color = "black")+
  ylab("Log Fold Change ± SE")+
  scale_color_manual(values = c("black", "red"))+
  theme(axis.title.x = element_text(size = 20),
        axis.text.x = element_text(size = 19),
        axis.title.y = element_text(size = 20),
        axis.text.y = element_text(size = 19),
        legend.title = element_text(size = 20),
        legend.text = element_text(size = 19),
        legend.text.align = 0)

ggplot_Temp

ggsave("plot.Temp_L2FC.pdf", plot = ggplot_Temp, path = "~/Documents/", width = 8.5, height = 8.5, dpi = 300, device = cairo_pdf)


ggplot_Temp
```

```{r, all conditions L2FC heatmap}
library(scico)
all_L2FC <- rbind(Res.Gas_Mars_H2_vs_H2CO2, Res.Pressure_Mars_12_vs_1500, Res.Temp_Mars_0_vs_30)

all_L2FC$Pathway_Position <- c(1:34)

plot_L2FC.heatmap <- ggplot(all_L2FC, aes(x = Condition, y = GeneID, fill = log2FoldChange))+
  geom_tile()+
  theme_classic()+
  coord_equal()+
  scale_fill_gradient2(low = "blue3", mid = "white", high = "red3", midpoint = 0, space = "rgb",
                      limits = c(-8,8), breaks = seq(-8,8,by=1))+
  theme(legend.text.align = 0,
        axis.title.x = element_text(size = 18, color = "black", face = "bold"),
        axis.text.x = element_text(size = 12, color = "black", angle = 90, hjust = 1),
        axis.title.y = element_text(size = 18, color = "black", face = "bold"),
        axis.text.y = element_text(size = 12, color = "black", face = "italic"),
        legend.title = element_text(size = 18, color = "black", face = "bold"),
        legend.text = element_text(size = 10, color = "black"))

plot_L2FC.heatmap

ggsave("plot.L2FC_heatmap.pdf", plot = plot_L2FC.heatmap, path = "~/Documents/", width = 4.6, height = 8.5, dpi = 300, device = cairo_pdf)

```

```{r, fragments/counts per million (FPM) calculations}
#add library size and mapped reads to K
## add a row to matrix K listing library size for each replicate column ##
K_library <- c(3684707,
3158558,
2960310,
6816895,
1502768,
3716133,
17598304,
2270993,
4275294,
3622071,
3197426,
5928626,
38288428,
81926029,
78909380,
91934309,
230056104,
278666451,
79322492,
108685065,
162987286,
45106486,
152477923,
127572080,
10841627,
41609610,
240146047,
121895594,
354393856,
404481110
)
## add a row to matrix K listing Bowtie2 alignment for M. barkeri coding sequence (CDS) genes ##
K_CDS <- c(80,
59065,
152,
260,
141,
39,
25117,
9,
131,
69,
8239,
28448,
16351820,
34197661,
29006886,
35908581,
104085443,
128827180,
30960977,
45223848,
71806582,
14969643,
70383513,
57796863,
2057333,
17518860,
104784212,
55374055,
169898456,
196347933)
#rbind to K


#figure this out -- how to visualize methanogenesis genes as a fraction of the total number of mapped transcripts
methanogenesis.counts <- colSums(counts(dds.LPMM)) #use dds.LPMM to include libraries with 0 mapped reads to the methanogenesis pathway
K_library.net <- K_library - methanogenesis.counts
K_CDS.net <- K_CDS - methanogenesis.counts

K2 <- rbind(K, K_library.net, K_CDS.net)
K3 <- as.data.frame(rbind(K, K_library, K_CDS))
write.csv(K3, file = "~/Documents/Bowtie2-mapping-stats.csv")
writexl::write_xlsx(x = K3, path = "~/Documents/Bowtie2-mapping-stats.xlsx")
                    
                    #file = "~/Documents/Bowtie2-mapping-stats.xlsx")


dds.LPMM_v3 <- DESeqDataSetFromMatrix(countData = K2,
                                  colData = colDataK,
                                  design = ~ Pressure + Gas + Temperature + Replicate) 

#use size factors to calculate fragments per million mapped reads
FPM.LPMM <- as.data.frame(fpm(dds.LPMM_v3, robust = TRUE))
FPM.LPMM$geneID <- rownames(FPM.LPMM)
FPM.LPMM <- FPM.LPMM[1:34,]
FPM.LPMM$Pathway_Position <- c(1:34)
write.csv(counts(dds.LPMM_v2), file = "~/Documents/transcript_counts.dds.LPMM_v2.csv")
write.csv(FPM.LPMM, file = "~/Documents/FPM.LPMM.csv")

melt.FPM.LPMM <- melt(FPM.LPMM, id.vars = c("geneID", "Pathway_Position"))
colnames(melt.FPM.LPMM) <- c("geneID", "Pathway_Position", "Replicate Library", "FPM")
melt.FPM.LPMM$gas <- ifelse(grepl("Mars", melt.FPM.LPMM$`Replicate Library`, ignore.case = T), "Mars mix", "80:20 H2:CO2") 
melt.FPM.LPMM$condition <- ifelse(grepl("0C_12mbar", melt.FPM.LPMM$`Replicate Library`, ignore.case = T), "0˚C & 7-12 mbar", 
                                  ifelse(grepl("30C_1.5bar", melt.FPM.LPMM$`Replicate Library`, ignore.case = T), "30˚C & 1500 mbar", "0˚C & 1500 mbar")) 

Mars.melt.FPM.LPMM <- melt.FPM.LPMM[melt.FPM.LPMM$gas=="Mars mix",]
H2CO2.melt.FPM.LPMM <- melt.FPM.LPMM[melt.FPM.LPMM$gas=="80:20 H2:CO2",]

library(RColorBrewer)
#generate a color palette 
getPalette <-colorRampPalette(brewer.pal(11, "Spectral"))
geneIDPalette <- getPalette(length(unique(melt.FPM.LPMM$geneID)))

legend.title <- "Gene"

library(forcats)
#plot FPM for Mars gas samples
plot.FPM.LPMM_Mars <- ggplot(Mars.melt.FPM.LPMM, aes(x = `Replicate Library`, y = FPM, fill = fct_reorder(geneID, FPM)))+
  geom_bar(stat = "identity", position = position_stack(reverse = TRUE))+
  scale_x_discrete(labels = c("1", "2", "3", "4", "1", "2", "3", "4", "1", "2", "3", "4"))+
  facet_grid(~condition, scales = "free_x", space = "free_x")+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE))+
  scale_fill_manual(legend.title, values = geneIDPalette, breaks = c("fmdA", "fmdB/fwdB", "fmdB", "fmdC/fwdC", "fmdC", "fmdD/fwdD","fmdD", "fwdD", "fmdE", "mvhB", "fwdG", "ftr", "mch","mtd", "mer", "mtrA", "mtrB", "mtrC", "mtrD", "mtrE", "mtrF", "mtrG", "mtrH", "mcrA", "mcrB", "mcrC", "mcrD", "mcrG", "K00400", "hdrD", "hdrE", "hdrA1A2", "hdrB1B2", "hdrC1C2"))+
  theme_bw()+
  ylab("FPM")+
  theme(axis.text.x=element_text(color = "black"),
        axis.text.y = element_text(color = "black"),
        strip.background = element_rect(fill = "white"),
        legend.title.align = 0.5)
  
plot.FPM.LPMM_Mars

#plot FPM for H2CO2 gas samples
plot.FPM.LPMM_H2CO2 <- ggplot(H2CO2.melt.FPM.LPMM, aes(x = `Replicate Library`, y = FPM, fill = fct_reorder(geneID, FPM)))+
  geom_bar(stat = "identity", position = position_stack(reverse = TRUE))+
  scale_x_discrete(labels = c("1", "2", "3", "4", "5", "6", "1", "2", "3", "4", "5", "6", "1", "2", "3", "4", "5", "6"))+
  facet_grid(~condition, scales = "free_x", space = "free_x")+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE))+
  scale_fill_manual(legend.title, values = geneIDPalette, breaks = c("fmdA", "fmdB/fwdB", "fmdB", "fmdC/fwdC", "fmdC", "fmdD/fwdD","fmdD", "fwdD", "fmdE", "mvhB", "fwdG", "ftr", "mch","mtd", "mer", "mtrA", "mtrB", "mtrC", "mtrD", "mtrE", "mtrF", "mtrG", "mtrH", "mcrA", "mcrB", "mcrC", "mcrD", "mcrG", "K00400", "hdrD", "hdrE", "hdrA1A2", "hdrB1B2", "hdrC1C2"))+
  theme_bw()+
  ylab("FPM")+
  theme(axis.text.x=element_text(color = "black"),
        axis.text.y = element_text(color = "black"),
        strip.background = element_rect(fill = "white"),
        legend.title.align = 0.5)
  
plot.FPM.LPMM_H2CO2
```


